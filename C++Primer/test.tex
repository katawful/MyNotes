\documentclass[12pt, a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage{listings}

\title{C++ Primer Notes}
\author{Kat}
\date{\today}

\begin{document}
\maketitle
\tableofcontents
\newpage
\chapter{Getting Started}
\section{Introduction}
Every C++ program has one or more functions, with one of these functions being \verb|main()|. A function is defined with four parts:
\begin{center}
	\begin{tabular}{ |c|c| }
		\hline
		R.T. & Return type \\
		\hline
		F.N. & Function type \\
		\hline
		P.L. & Parameter list, maybe empty \\
		\hline
		F.B. & Function body, inside braces \\
		\hline
	\end{tabular}
\end{center}
For example, a basic \verb|main()| function would look like this:
\begin{center}
\begin{lstlisting}[language=C++]
	int main() { 
		return 0;
	}
\end{lstlisting}
\end{center}
\verb|int| is the return type, with the function \verb|main| requiring an \verb|int| R.T. A semicolon (\verb|;|) closes a statement inside a function. For \verb|main()|, the function returns a status indicator. Thus \verb|return| is required, with \verb|0| indicating a success.

Every data element (called objects in C++) must have a type. The type lets the compiler know what operations are possible on the object. 
For instance, say we have a variable \verb|v| and the type of \verb|v| is \verb|T|. It would be described as ``\verb|v| has type \verb|T|''
or ``\verb|v| is a \verb|T|''. Types are integral to C++ and must always be given for any object.
\section{Compiling}
C++ is a compiled language, meaning that a compiler is required to take the human friendly language to something a computer can understand.
This is in contrast to a language like Python in which the language you write in is the language that is run.
\subsection{The GNU Compiler Collection: GCC}
Since I am using Linux, the primary C++ compiler of use is GCC. While this has other compilers for different languages, we are concerned with \verb|G++|.
For simple programs, the primary usage is as follows: 

\begin{center}
	\verb|$ g++ -o output input.cpp|
\end{center}

\section{Input/Output}
C++ doesn't natively handle input and output operations but relies on a built in library called \verb|iostream|. C++ gets input/output data via a stream, a sequence of characters read or written to an IO device that is generated or consumed sequentially. 
In the \verb|iostream| library there are two types of streams: \verb|istream| and \verb|ostream|. There are a handful of IO objects in this library that we can classify:

\begin{center}
	\begin{tabular}{ |c|c|c| }
		\hline
		\textbf{Function} & \textbf{Use} & \textbf{Note} \\
		\hline
		\verb|cin| & Standard input & Type \verb|istream| \\
		\hline
		\verb|cout| & Standard output & Type \verb|ostream| \\
		\hline
		\verb|cerr| & Standard error & For general errors \\
		\hline
		\verb|clog| & Standard log & For general info on the program \\
		\hline
	\end{tabular}
\end{center}

\section{Namespaces}
C++ has many functions, and some share names between libraries. The compiler and author have to know what object one is referring to. To do this, we prepend a namespace to the object in question and link them with a scope operator:

\begin{lstlisting}[language=C++]
	std::cout
\end{lstlisting}

\verb|std| is the standard C++ namespace and most objects in the standard libraries use this namespace. \verb|::| is the scope operator and it lets us describe a namespace within a scope.

\subsection{Headers}
A header links to a library and we use them in C++ programs via the \verb|#include| director. This is used outside of the function and tells the compiler to include the library while compiling. It is used like so:

\begin{center}
	\verb|#include <iostream>|
\end{center}
\section{Comments}
Comments are integral to any programming language. They improve readability and help the author and people reading the code to better understand the code at hand.
In C++ there are two kinds of comments: single-line and paired.
\subsection{Single-line Comments}
Single-line comments are made with two forwardslashes, \verb|//|. Everything past this is not read by the compiler up until a newline is made. For example:

\begin{scriptsize}
\begin{lstlisting}[language=C++]
std::cout;; // this comment keeps the code in view of the compiler
// std::cout;
// in the line above, the code is commented out
\end{lstlisting}
\end{scriptsize}

\subsection{Paired Comments}
A paired comment lets one create large blocks of comments, particularily on multiple lines, without having to use single-line comments for each line.
A paired comment is started with \verb|/*| and ends on the \emph{first} instance of \verb|*/|. This last part is important and means we can't nest paired comments.
If we wanted to comment out a section of code that contains a set of paired comments, we would be unable to. For instance:

\begin{flushleft}
\noindent \verb|/* we start our comment here| \\
\verb|stuff /* paired */| \\
\verb|we end our paired here */| \\
\end{flushleft}

\noindent In this example the paired comment ends in the second line at the first \verb|*/|. This leaves the second \verb|*/| without an initial \verb|/*|.
This block would thus be invalid. And so in order to comment out paired comments, one should use single-line comments for every line involved.
\section{The $for$ Statement}
In C++, \verb|while| loops are very common. The most common of these are \verb|while| loops that increment a value until it reaches a condition set by the author:

\begin{lstlisting}[language=C++]
while ( i < 10 ) {
	do stuff;
	++i
}
\end{lstlisting}

\noindent Since this \verb|while| loop is so prominent, C++ introduced a new function to replicate it simpler: the \verb|for| loop.
A \verb|for| loop contains three parts in its header: a init statement, a condition, and an expression.

\begin{center}
	\begin{tabular}{ |c|c|c| }
		\hline
		\textbf{Part} & \textbf{Example} & \textbf{Description} \\
		\hline
		Init statement & \verb|int val = 1;| & Defines a variable for the loop \\
		\hline
		Condition & \verb|val <= 10;| & Describes when to end the loop \\
		\hline
		Expression & \verb|++val| & What to do after each loop \\
		\hline
	\end{tabular}
\end{center}
And all together this would become:
\begin{lstlisting}[language=C++]
for ( int val = 1; val <= 10; ++val) {
	stuff;
	maybe more stuff;
}
\end{lstlisting}
It is important to note that only the first two parts are ended by a semicolon, the expression is not ended by a semicolon. 
\section{Data Structures}
In C++ we often want to be able to define our own objects, types, and functions. This is, in fact, what makes C++ so powerful. We can arbitrarily add in our own classes that behave like standard classes. 
A data class defines a type along with a collection of operations related to that type. In order to include these we must have a file (typically '*.h') and include it into our program. We can do that with \verb|#include "Our_class.h"|. In a class we can have member functions, functions defined as part of a class.
These are sometimes called methods. We use these on objects of the class type and format as such: \verb|object.method()|.
\section{Notes}

\begin{itemize}
	\item A semicolon ends a statement.
	\item The scope operator (\verb|::|) is used to define the name of an object.
	\item We can read from an input stream by using \verb|while ( cin << input )|
	\item We can read from a file and output to a file: \\ \verb|program <infile >outfile|
\end{itemize}

\chapter{Variables and Basic Types}
\section{Arithmetic Types}
There are many types in standard C++ libraries. The arithmetic types allow arithmetic operations to be applied to them. There are two basic types: integral and floating point types. Both allow different sizes for different uses and integral types can be either signed or unsigned.
It is best practice then to restrict the types one uses. If only integer math is needed then floats shouldn't be used. If a value will never be negative, the integer should be unsigned. 
Floats should always be double precision, they are more accurate and take up a bit more in memory.
Types like char and boolean should never be used for arithmetic.

\noindent We can convert one type to another on the fly depending on some conditions. This lets us treat some variables differently when we want to. There are some limitations and conditions we should be aware of:
\begin{center}
	\begin{tabular}{ |c|c| }
		\hline
		\textbf{Conversion} & \textbf{Conditions} \\
		\hline
		Non-bool $\rightarrow$ bool & 0 is false, otherwise true \\
		\hline
		Bool $\rightarrow$ non-bool & True is 1, false is 0 \\
		\hline
		Float $\rightarrow$ integral & Truncated, integer component is kept \\
		\hline
		Integral $\rightarrow$ float & Fractional part is 0, can lose precision \\
		\hline
		Out-of-range $\rightarrow$ unsigned & Remainder of the value modulo \\
		\hline
		Out-of-range $\rightarrow$ signed & Undefined, produces unexpected results \\
		\hline
	\end{tabular}
\end{center}
\section{Literals}
Literals are self-evident value. For instance ``3'' is a literal. We know what it means just looking at it. There are many types of literals:
\begin{center}
	\begin{tabular}{ |c|c| }
		\hline
		\textbf{Type} & \textbf{Example} \\
		\hline
		Decimal & 3 \\
		\hline
		Octal & 0\# \\
		\hline
		Hexidecimal & 0x\# \\
		\hline
		Character & `c' \\
		\hline
		String & ``word'' \\
		\hline
	\end{tabular}
\end{center}

\section{Escape Sequences}
Sometimes we want to enter a specific kind of input, but due to the way C++ we catn't input them as we would want to. We use a backslash $\backslash$ folowed by a neccessary character. There are many escape sequences and they can be used in many places:
\begin{center}
	\begin{tabular}{ |c|c| }
		\hline
		\textbf{Escape Sequence} & \textbf{Function} \\
		\hline
		$\backslash$n & Newline \\
		\hline
		$\backslash$t & Horizontal tab \\
		\hline
		$\backslash$a & Terminal alert/bell \\
		\hline
		$\backslash$v & Vertical tab \\
		\hline
		$\backslash$b & Backspace \\
		\hline
		$\backslash$`` & Double quote \\
		\hline
		$\backslash$$\backslash$ & Backslash \\
		\hline
		$\backslash$? & Question mark \\
		\hline
		$\backslash$` & Single quote \\
		\hline
		$\backslash$r & Carriage return \\
		\hline
		$\backslash$f & Form feed \\
		\hline
	\end{tabular}
\end{center}
One can also use octal/hex values with escape sequences to insert a specific character (such as a non-English character, symbol, ect...)
\section{Variables}
Variables in C++ are named storage that can be manipulated and has a type. The type determines size and layout of memory, its range of values, and set of operations possible on the variable.
\subsection{Creating Variables}
Creating variables is the first thing a variable needs. There are two main ways to do it: a declaration and a definition. A definition is a \emph{declaration} and an \emph{initialization}.
\subsubsection{Declaration}
A declaration makes a name known to the program along with its associated type. A declared object does not have any value associated with it, this is known as \textbf{default initialization}. For built in types, default initialized values are 0 when called declared outside of a function and undefined when inside a function:
\begin{lstlisting}[language=C++]
int i;	// value is 0
int main() {
	int i;	// value is undefined
}
\end{lstlisting}
\noindent Classes can be supplied with their own default values.
\subsubsection{Initialization}
Initialization is when you declare and immediately give a value to an object as opposed to assignment which clears out the existing value and gives it a new one.
There are 4 main ways to initialize an object:
\begin{lstlisting}[language=C++]
int x = 0;
int x = {0}
int x{0}
int x(0)
\end{lstlisting}
Initializations with curly braces are known as \textbf{list initialization}. These are very specific and the compiler won't compile our code if information is lost (say a float is used in an initialization for an integer)

A definition combines these two things, and as a result you can only define once. You can, however, declare multiple times.
This is important if we want to carry one variable from one file to another. To do so, we declare or define the variable in a main file then use the keyword \verb|extern| to only declare the variable in other files.
\section{Identifiers}
We can name objects in many different ways, but there are some rules. Names used by standard libraries are unavailable (e.g. \verb|cin|) for use. Underscores can't be used more than once in a row, can't begin with an underscore followed by an uppercase letter, and identifiers defined outside of a function can't begin with an underscore. Aside from those exceptions, the rules are fairly lax. Any combination of numbers and letters can be used. Some common ways to create an identifier can be:
\begin{center}
	\begin{itemize}
		\item \verb|wordName|
		\item \verb|word_Name|
		\item \verb|Word_name|
	\end{itemize}
\end{center}
\section{Scope}
A scope is a part of a progam where a name has a certain meaning. Usually these are things enclosed in curly braces. hellp 
\end{document}
