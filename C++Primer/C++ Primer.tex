\documentclass[12pt, a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage{listings}

\title{C++ Primer Notes}
\author{Kat}
\date{\today}

\begin{document}
\maketitle
\tableofcontents
\newpage
\chapter{Getting Started}
\section{Introduction}
Every C++ program has one or more functions, with one of these functions being \verb|main()|. A function is defined with four parts
\begin{center}
  \begin{tabular}{ |c|c| }
    \hline
    R.T. & Return type \\
    \hline
    F.N. & Function type \\
    \hline
    P.L. & Parameter list, maybe empty \\
    \hline
    F.B. & Function body, inside braces \\
    \hline
  \end{tabular}
\end{center}
For example, a basic \verb|main()| function would look like this:
\begin{center}
  \begin{lstlisting}[language=C++]
    int main() { 
        return 0;
    }
  \end{lstlisting}
\end{center}
\verb|int| is the return type, with the function \verb|main| requiring an \verb|int| R.T. A semicolon (\verb|;|) closes a statement inside a function. For \verb|main()|, the function returns a status indicator. Thus \verb|return| is required, with \verb|0| indicating a success.

Every data element (called objects in C++) must have a type. The type lets the compiler know what operations are possible on the object. 
For instance, say we have a variable \verb|v| and the type of \verb|v| is \verb|T|. It would be described as ``\verb|v| has type \verb|T|''
or ``\verb|v| is a \verb|T|''. Types are integral to C++ and must always be given for any object.
\section{Compiling}
C++ is a compiled language, meaning that a compiler is required to take the human friendly language to something a computer can understand.
This is in contrast to a language like Python in which the language you write in is the language that is run.
\subsection{The GNU Compiler Collection: GCC}
Since I am using Linux, the primary C++ compiler of use is GCC. While this has other compilers for different languages, we are concerned with \verb|G++|.
For simple programs, the primary usage is as follows: 

\begin{center}
  \verb|$ g++ -o output input.cpp|
\end{center}

\section{Input/Output}
C++ doesn't natively handle input and output operations but relies on a built in library called \verb|iostream|. C++ gets input/output data via a stream, a sequence of characters read or written to an IO device that is generated or consumed sequentially. 
In the \verb|iostream| library there are two types of streams: \verb|istream| and \verb|ostream|. There are a handful of IO objects in this library that we can classify:

\begin{center}
  \begin{tabular}{ |c|c|c| }
    \hline
    \textbf{Function} & \textbf{Use} & \textbf{Note} \\
    \hline
    \verb|cin| & Standard input & Type \verb|istream| \\
    \hline
    \verb|cout| & Standard output & Type \verb|ostream| \\
    \hline
    \verb|cerr| & Standard error & For general errors \\
    \hline
    \verb|clog| & Standard log & For general info on the program \\
    \hline
  \end{tabular}
\end{center}

\section{Namespaces}
C++ has many functions, and some share names between libraries. The compiler and author have to know what object one is referring to. To do this, we prepend a namespace to the object in question and link them with a scope operator:

\begin{lstlisting}[language=C++]
    std::cout
\end{lstlisting}

\verb|std| is the standard C++ namespace and most objects in the standard libraries use this namespace. \verb|::| is the scope operator and it lets us describe a namespace within a scope.

\subsection{Headers}
A header links to a library and we use them in C++ programs via the \verb|#include| director. This is used outside of the function and tells the compiler to include the library while compiling. It is used like so:

\begin{center}
  \verb|#include <iostream>|
\end{center}
\section{Comments}
Comments are integral to any programming language. They improve readability and help the author and people reading the code to better understand the code at hand.
In C++ there are two kinds of comments: single-line and paired.
\subsection{Single-line Comments}
Single-line comments are made with two forwardslashes, \verb|//|. Everything past this is not read by the compiler up until a newline is made. For example:

\begin{scriptsize}
  \begin{lstlisting}[language=C++]
std::cout;; // this comment keeps the code in view of the compiler
// std::cout;
// in the line above, the code is commented out
  \end{lstlisting}
\end{scriptsize}

\subsection{Paired Comments}
A paired comment lets one create large blocks of comments, particularily on multiple lines, without having to use single-line comments for each line.
A paired comment is started with \verb|/*| and ends on the \emph{first} instance of \verb|*/|. This last part is important and means we can't nest paired comments.
If we wanted to comment out a section of code that contains a set of paired comments, we would be unable to. For instance:

\begin{flushleft}
  \noindent \verb|/* we start our comment here| \\
  \verb|stuff /* paired */| \\
  \verb|we end our paired here */| \\
\end{flushleft}

\noindent In this example the paired comment ends in the second line at the first \verb|*/|. This leaves the second \verb|*/| without an initial \verb|/*|.
This block would thus be invalid. And so in order to comment out paired comments, one should use single-line comments for every line involved.
\section{The $for$ Statement}
In C++, \verb|while| loops are very common. The most common of these are \verb|while| loops that increment a value until it reaches a condition set by the author:

\begin{lstlisting}[language=C++]
while ( i < 10 ) {
    do stuff;
    ++i
}
\end{lstlisting}

\noindent Since this \verb|while| loop is so prominent, C++ introduced a new function to replicate it simpler: the \verb|for| loop.
A \verb|for| loop contains three parts in its header: a init statement, a condition, and an expression.

\begin{center}
  \begin{tabular}{ |c|c|c| }
    \hline
    \textbf{Part} & \textbf{Example} & \textbf{Description} \\
    \hline
    Init statement & \verb|int val = 1;| & Defines a variable for the loop \\
    \hline
    Condition & \verb|val <= 10;| & Describes when to end the loop \\
    \hline
    Expression & \verb|++val| & What to do after each loop \\
    \hline
  \end{tabular}
\end{center}
And all together this would become:
\begin{lstlisting}[language=C++]
for ( int val = 1; val <= 10; ++val) {
    stuff;
    maybe more stuff;
}
\end{lstlisting}
It is important to note that only the first two parts are ended by a semicolon, the expression is not ended by a semicolon. 
\section{Data Structures}
In C++ we often want to be able to define our own objects, types, and functions. This is, in fact, what makes C++ so powerful. We can arbitrarily add in our own classes that behave like standard classes. 
A data class defines a type along with a collection of operations related to that type. In order to include these we must have a file (typically '*.h') and include it into our program. We can do that with \verb|#include "Our_class.h"|. In a class we can have member functions, functions defined as part of a class.
These are sometimes called methods. We use these on objects of the class type and format as such: \verb|object.method()|.
\section{Notes}

\begin{itemize}
  \item A semicolon ends a statement.
  \item The scope operator (\verb|::|) is used to define the name of an object.
  \item We can read from an input stream by using \verb|while ( cin << input )|
  \item We can read from a file and output to a file: \\ \verb|program <infile >outfile|
\end{itemize}

\chapter{Variables and Basic Types}
\section{Arithmetic Types}
There are many types in standard C++ libraries. The arithmetic types allow arithmetic operations to be applied to them. There are two basic types: integral and floating point types. Both allow different sizes for different uses and integral types can be either signed or unsigned.
It is best practice then to restrict the types one uses. If only integer math is needed then floats shouldn't be used. If a value will never be negative, the integer should be unsigned. 
Floats should always be double precision, they are more accurate and take up a bit more in memory.
Types like char and boolean should never be used for arithmetic.

\noindent We can convert one type to another on the fly depending on some conditions. This lets us treat some variables differently when we want to. There are some limitations and conditions we should be aware of:
\begin{center}
  \begin{tabular}{ |c|c| }
    \hline
    \textbf{Conversion} & \textbf{Conditions} \\
    \hline
    Non-bool $\rightarrow$ bool & 0 is false, otherwise true \\
    \hline
    Bool $\rightarrow$ non-bool & True is 1, false is 0 \\
    \hline
    Float $\rightarrow$ integral & Truncated, integer component is kept \\
    \hline
    Integral $\rightarrow$ float & Fractional part is 0, can lose precision \\
    \hline
    Out-of-range $\rightarrow$ unsigned & Remainder of the value modulo \\
    \hline
    Out-of-range $\rightarrow$ signed & Undefined, produces unexpected results \\
    \hline
  \end{tabular}
\end{center}
\section{Literals}
Literals are self-evident value. For instance ``3'' is a literal. We know what it means just looking at it. There are many types of literals:
\begin{center}
  \begin{tabular}{ |c|c| }
    \hline
    \textbf{Type} & \textbf{Example} \\
    \hline
    Decimal & 3 \\
    \hline
    Octal & 0\# \\
    \hline
    Hexidecimal & 0x\# \\
    \hline
    Character & `c' \\
    \hline
    String & ``word'' \\
    \hline
  \end{tabular}
\end{center}

\section{Escape Sequences}
Sometimes we want to enter a specific kind of input, but due to the way C++ we catn't input them as we would want to. We use a backslash $\backslash$ folowed by a neccessary character. There are many escape sequences and they can be used in many places:
\begin{center}
  \begin{tabular}{ |c|c| }
    \hline
    \textbf{Escape Sequence} & \textbf{Function} \\
    \hline
    $\backslash$n & Newline \\
    \hline
    $\backslash$t & Horizontal tab \\
    \hline
    $\backslash$a & Terminal alert/bell \\
    \hline
    $\backslash$v & Vertical tab \\
    \hline
    $\backslash$b & Backspace \\
    \hline
    $\backslash$`` & Double quote \\
    \hline
    $\backslash$$\backslash$ & Backslash \\
    \hline
    $\backslash$? & Question mark \\
    \hline
    $\backslash$` & Single quote \\
    \hline
    $\backslash$r & Carriage return \\
    \hline
    $\backslash$f & Form feed \\
    \hline
  \end{tabular}
\end{center}
One can also use octal/hex values with escape sequences to insert a specific character (such as a non-English character, symbol, ect...)
\section{Variables}
Variables in C++ are named storage that can be manipulated and has a type. The type determines size and layout of memory, its range of values, and set of operations possible on the variable.
\subsection{Creating Variables}
Creating variables is the first thing a variable needs. There are two main ways to do it: a declaration and a definition. A definition is a \emph{declaration} and an \emph{initialization}.
\subsubsection{Declaration}
A declaration makes a name known to the program along with its associated type. A declared object does not have any value associated with it, this is known as \textbf{default initialization}. For built in types, default initialized values are 0 when called declared outside of a function and undefined when inside a function:
\begin{lstlisting}[language=C++]
int i;	// value is 0
int main() {
    int i;	// value is undefined
}
\end{lstlisting}
\noindent Classes can be supplied with their own default values.
\subsubsection{Initialization}
Initialization is when you declare and immediately give a value to an object as opposed to assignment which clears out the existing value and gives it a new one.
There are 4 main ways to initialize an object:
\begin{lstlisting}[language=C++]
int x = 0;
int x = {0}
int x{0}
int x(0)
\end{lstlisting}
Initializations with curly braces are known as \textbf{list initialization}. These are very specific and the compiler won't compile our code if information is lost (say a float is used in an initialization for an integer)

A definition combines these two things, and as a result you can only define once. You can, however, declare multiple times.
This is important if we want to carry one variable from one file to another. To do so, we declare or define the variable in a main file then use the keyword \verb|extern| to only declare the variable in other files.
\section{Identifiers}
We can name objects in many different ways, but there are some rules. Names used by standard libraries are unavailable (e.g. \verb|cin|) for use. Underscores can't be used more than once in a row, can't begin with an underscore followed by an uppercase letter, and identifiers defined outside of a function can't begin with an underscore. Aside from those exceptions, the rules are fairly lax. Any combination of numbers and letters can be used. Some common ways to create an identifier can be:
\begin{center}
  \begin{itemize}
    \item \verb|wordName|
    \item \verb|word_Name|
    \item \verb|Word_name|
  \end{itemize}
\end{center}
\section{Scope}
A scope is a part of a progam where a name has a certain meaning. Usually these are things enclosed in curly braces. A scope can be nested. A \verb|for| inside a \verb|main()| function is nested. Variables defined in the \verb|main()| function are seen by any nested scopes, but a variable defined in a scope is only seen by further nested scopes. This is overridden by the scope operator (\verb|::|).
\section{Compound Types}
A compound type is a type defined in terms of another. C++ has multiple compound types but the two discussed here are \textbf{reference} and \textbf{pointer}. Defining these types are a bit more complex than normal types.
\subsection{References}
A reference defines an alternative name for an object. A reference refers to another type. We use \verb|&d| for definition, with d being the name being declared. A reference binds to an initializer of another type, and because of this the object being reference \emph{must} be initialized. The reference we are defining must also be the same type as the object we are referencing. It also can't be a literal. We also can't define a reference to a reference.
\subsection{Pointers}
A pointer points to another type. It allows indirect access to the object that it points to, but unlike references, it's its own object.
It doesn't need to be initialized. We define a pointer using \verb|*d| with d being the pointer name. 
Pointers hold the address of the object it points to. We can get the address using the address-of operator (\verb|&|). The value stored in the pointer can be one of 4 states:
\begin{center}
  \begin{enumerate}
    \item Point to an object
    \item Point to the location just past the end of the object
    \item Null, the pointer points to nothing
    \item Invalid, any value not the ones above
  \end{enumerate}
\end{center}
In order to access the object in which the pointer points to we use dereference the pointer using the dereference operator (\verb|*|). This allows us to perform most operations on the object without modifying the pointer itself.

\noindent Since pointers are objects, we can assign them new values. However, it can be a touch confusing if we want to change the pointer or the object it points to. To change the pointer we \emph{don't} dereference the pointer. Assigning the object a pointer points to requires a dereferenced pointer.

\noindent We can also use pointers in conditions. A pointer is false if its equal to 0, and true otherwise. We can compare two pointers as well. They are equal if they hold the same address (not just the same value).
\newline We can also apply multiple type of modifiers to a declarator. This lets us have pointers that point to pointers. References to pointers can also be created, but pointers to references cannot as references are not objects. To create a reference to a pointer we simply use the \textbf{dereference operator} while declaring the pointer.
\subsubsection{Null Pointers}
Null pointers can be useful when we don't have an object to point to but still need the pointer around. The best way to initialize a null pointer is to use \verb|nullptr|. There are other methods, but require a preprocessor variable. It is always best to initialize a pointer to something.
\subsubsection{void* Pointers}
As pointers are objects they neccessarily have a type. This lets us perform operations on them like any other object. However, that sometimes can get in our way. If we care more about pointers as an address of memory, we don't want to be concerned with the type of the pointer.
The \verb|void*| pointer lets us create a pointer of unknown type. We can create it simply by type \verb|void *p = &obj|. That pointer can hold an object of any type and a pointer of any type.

\section{const Qualifier}
There are many cases in which we want to keep a variable unchanged. To do this we simply add the qualifier \verb|const| to the beginning of the declaration of the variable. When a \verb|const| is created we cannot change the variable and we will cause an error. Uninitialized \verb|const| variables will also cause errors. However, we are allowed to perform any operation on a \verb|const| that doesn't change the variable.
\subsection{const References}
A reference to a \verb|const| cannot be used to change the value. In this case it means we can't make a non-\verb|const| reference to a \verb|const| variable. We can initialize a reference to a \verb|const| with a type that isn't the type of the reference. The compiler does this by creating a temporary variable that holds a \verb|const| of the type in question. A reference to a \verb|const| may refer to a value that isn't a \verb|const|. References to \verb|const| are thus used when we don't want to change the \emph{reference} only.
\subsection{const Pointers}
A pointer to a \verb|const| cannot change the object to which the pointer points. However, a \verb|const| pointer can point to a non-\verb|const| object. We just can't change the object to which the pointer points.
\subsection{Top-Level and Low-Level const}
Since a pointer can either be a \verb|const| or point to a \verb|const|, it is important to distinguish what kind of \verb|const| we are referring to. A \textbf{top-level const} indicates that the pointer itself is a \verb|const|. A \textbf{low-level const} indicates that the pointer points to a \verb|const| object. More generally, a low-level \verb|const| refers to the base of a compound type like pointer or reference while top-level \verb|const| refers to the object itself.
This is important when we copy values. Top-level \verb|const| is ignored when copying. This makes sense since copying an object doesn't change the object. On the other hand, low-level \verb|const| \emph{isn't} ignored when copying. The object itself is a \verb|const| and that can't change.
\newline In general, we can convert non-\verb|const| to \verb|const| but not the other way around.
\subsection{Constant Expression}
Sometimes we want the output of a specific expression, but we don't want that value to be changed. We can use a constant expression that is evaluated at compile time that gives us a constant value of an expression. It lets us confirm that what we have is a \verb|const|. Our use of \verb|constexpr| is limited however. It is generally limited to literal types like arithmetic, pointers, and references. \verb|constexpr| pointers apply to the pointer and not the object it points to.
\section{Dealing with Types}
As programs get more complex, types get more complex. Thus we would want to simplify our usage of types as best as we can. 
\subsection{Type Alias}
One thing we can do is create type aliases. These are names that are synonyms of another type. One way to create a type alias is by using the \verb|typedef| keyword when declaring a type (e.g. \verb|typedef double wages;|, wages is an alias for double). A limitation though, is that we can only decalare with the \verb|typedef| keyword.
An \textbf{alias declaration} can simplify this. The syntax is as follows: \verb|using name = type;|. The name is whatever alias name we want. This alias can then be used wherever a type name might appear. An important thing to remember is that an alias made through \verb|typedef| uses the base type and isn't just a name substitution.
\subsection{auto Type Specifier}
When types can get too complex, we can use the type specifier \verb|auto| to have the compiler guess what the type is. The compiler has some quirks with respect to \verb|auto| however. It uses the base object, so reference types are ignored for what the reference refers to. It ignores all top level \verb|const|s so we must specify if the type is a \verb|const| if we care about it.
\subsection{decltype Type Specifier}
When we want to be more specific and get the deduced type of the item in question, we use \verb|decltype|. This gives us the type of the \emph{operand} rather than the object. This returns top-level \verb|const| and the type of the reference, giving us a good bit more specificity.
\section{Defining a Data Structure}
Creating our own data structures is incredibly useful and is relatively simple:
\begin{lstlisting}[language=C++]
struct name {
    x
};
\end{lstlisting}
With x being our data elements. We prepend this to our program and the program pretends that the data was defined in our program. The names in the class must be unique to the class, and we are able to initialize any objects to give them a default initialization value. We can also make it a separate file and include it in our program. The preprocessor does the same prepending as we did. To do that we use: \verb|#include "Data_structure.h"| with ``Data\_structure'' being our data file and in the same location as the source code is compiled in.
\subsection{Header Guards}
Obviously we want to include this file in every part of the program that needs it. However, we don't want to risk including it more than one time. Doing so will cause issues. To do that we use preprocessor variables to describe the condition of header file. These are: 
\begin{center}
  \begin{tabular}{ |c|c| }
    \hline
    \textbf{Variable Type} & \textbf{Variable} \\
    \hline
    Defined & \verb|#DEFINE| \\
    \hline
    Not defined & No variable \\
    \hline
    If defined & \verb|#IFDEF| + \verb|#ENDIF| \\
    \hline
    If not defined & \verb|#IFNDEF| + \verb|#ENDIF| \\
    \hline
  \end{tabular}
\end{center}
These should always be written in a way that the header file is included only once if we want it. The preprocessor variables should also be written in caps to avoid any confusion.
\section{My Notes}
\begin{itemize}
  \item Types are integral to C++
  \item Types define operations on objects
  \item Can use header files to define our own types
  \item Always include header files once using preprocessor variables
\end{itemize}

\chapter{Strings, Vectors, and Arrays}
\section{Namespace Declaration}
Previously, we had to specify the namespace of every function/operator we wanted to use. We can instead set the namespace of a function inside a scope by calling the namespace before a function starts. Generally, these are added underneath our included libraries. They are declared using the \verb|using| declarator,
e.g. \verb|using std::cout;|. We don't want to use this inside header files however.

\section{Library string Type}
Using the \verb|std| namespace, the \verb|string| library lets us create and modify strings. We must, of course, initialize the string and there are many ways to do so:
\begin{center}
  \begin{tabular}{ |c|c| }
    \hline
    \textbf{Initialization} & \textbf{Result} \\
    \hline
    \verb|string s1;| & Default initialization, empty string \\
    \hline
    \verb|string s2(s1);| & s2 is a copy of s1 \\
    \hline
    \verb|string s2 = s1;| & Same as above \\
    \hline
    \verb|string s3("value");| & s3 is a copy of string literal, not including the null \\
    \hline
    \verb|string s3 = "value";| & Same as above \\
    \hline
    \verb|string s4(n, 'c');| & Initialize s4 with \verb|n| copies of character `\verb|c|' \\
    \hline
  \end{tabular}
\end{center}
\subsection{Direct vs Copy Initialization}
A copy initialization uses \verb|=| to copy the right object to the left object during creation. A direct initialization doesn't have this.
We use copy initialization for single initialization, but if we want to initialize a variable from more than one value we must use direct initialization
(see the initialization of s4).
\section{string Operators}
There are many operators for the \verb|string| type. Here are some examples:
\begin{center}
  \begin{tabular}{ |c|c| }
    \hline
    \textbf{Operator} & \textbf{Function} \\
    \hline
    \verb|os << s| & Writes s onto output stream os, returns os \\
    \hline
    \verb|is >> s| & Read whitespace separated string from is into s, returns is \\
    \hline
    \verb|getline(is, s)| & Read line input from is to s, returns is using newline \\
    \hline
    \verb|s.empty()| & Returns true if s is empty, else false \\
    \hline
    \verb|s.size()| & Returns the number of characters in s \\
    \hline
    \verb|s[n]| & Returns reference to character at position \verb|n| in s, starts from 0 \\
    \hline
    \verb|s1 + s2| & Returns string cocantenation of s1 and s2 \\
    \hline
    \verb|s1 = s2| & Replaces s1 with a copy of s2 \\
    \hline
    \verb|==, !=, <, <=, >, >=| & Equalities are case sensitive and use dictionary sorting. \\
    \hline
  \end{tabular}
\end{center}
We can read a string from an input buffer in the same manner as we can an integer. The \verb|size()| operator returns the type \verb|string::size_type|.
The auto/decltype type specifier should be used when using this operator for convenience. It is unsigned.
The cocantenation operator requires one string to work. 

In addition to these, there are many functions in the \verb|cctype| header that allow control over the characters of a string.
\subsection{Ranged for}
Modifying characters in a string is a pretty common thing, and in order to do so we use a reference to the characters in the string.
Modifying the reference then switching to the next character reference is the best way to work through each character in the string.
A ranged for is set up as so:
\begin{lstlisting}[language=C++]
for ( &c : s)
    do stuff
\end{lstlisting}
\subsection{The Subscript Operator}
If we want to access a single character in a string, we use the subscript operator (\verb|[]|). Starting at 0, the subscript operator uses the
\verb|string::size_type| type as the index/subscript. If the index doesn't correspond to a valid character, the subscript is invalid.
\section{Library vector Type}
A \verb|vector| in C++ is a collection of objects of the same type, also called a container. Vectors are contained in the \verb|vector| header in the standard namespace, \verb|std|. This lets us create \emph{class templates}. A class template is a way for the compiler to generate classes and functions. For vectors, 
we need to specify that we want to create a vector of a certain type: \verb|vector<type> name|. This creates the vector type from a template, creating a new type called \verb|vector<type>|. While vectors of references are not possible, there are many ways to create vectors:
\begin{center}
  \begin{tabular}{ |c|c| }
    \hline
    \textbf{Initializer} & \textbf{Result} \\
    \hline
    \verb|vector<T> v1| & Vector v1 holds object of type T, default initialization \\
    \hline
    \verb|vector<T> v2(v1)| & v2 has copy of each element in v1 \\
    \hline
    \verb|vector<T> v2 = v1| & Same as above \\
    \hline
    \verb|vector<T> v3(n, val)| & v3 has \verb|n| elements, each with value val \\
    \hline
    \verb|vector<T> v4(n)| & v4 has \verb|n| elements of default-initialization \\
    \hline
    \verb|vector<T> v5{a,b,c...}| & v5 has number of elements as initializors \\
    \hline
    \verb|vector<T> v5 = {a,b,c...}| & Same as above \\
    \hline
  \end{tabular}
\end{center}
There's an important distinction that vectors have. Parentheses \verb|()| are for constructing objects while braces \verb|{}| are for list initialization.
List initialization adds the value to the vector, but object construction creates objects based on specific parameters. 
The vector \verb|vector<int> v1{10}| creates a vector with \emph{1} object of value \emph{10}.
The vector \verb|vector<int> v2(10)| creates a vector with \emph{10} objects of value \emph{0}. This is an important distinction and should be thought of.	
\section{vector Operations}
There are many vector operations and some are shared between similar library types:
\begin{center}
  \begin{tabular}{ |c|c| }
    \hline
    \textbf{Operation} & \textbf{Function} \\
    \hline
    \verb|v.empty()| & Returns true if v is empty, otherwise false \\
    \hline
    \verb|v.size()| & Returns size of vector, the number of elements \\
    \hline
    \verb|v.push_back(t)| & Adds element of value t to the end of v \\
    \hline
    \verb|v[n]| & Returns reference to element at position \verb|n| \\
    \hline
    \verb|v1 = v2| & Replace the elements of v1 with the copy of elements in v2 \\
    \hline
    \verb|v1 = {a,b,c...}| & Replace elements in v1 with copy elements in the list \\
    \hline
    \verb|==, !=, <, <=, >, >=| & Vectors are equal if they have the same amount \\
                                & of elements and each element corresponds to the \\
                                & elements in the other vector, dictionary sorting \\
                                \hline
  \end{tabular}
\end{center}
We can't use a ranged for loop if the body of the loop adds elements to the vector. We can however, access elements in a vector in the same manner as a string.
The size operation returns a \verb|size_type| type. Use of auto/decltype is encouraged.
\section{Iterators}
Iterators allow us to indirectly access elements in a container/object, they let us walk through them. Types with iterators have members that return iterators.
We can access the beginning and the end iterators in a container by using the \verb|begin()| and the \verb|end()| operators respectively. 
\verb|begin()| returns the iteraotr that denotes the first element, \verb|end()| returns the iterator positioned one past the end.
These operators don't care about type, and are mostly used to determine if we have processed all the elements.
\subsection{Iterator Operations}
There are a good number of iterator operations:
\begin{center}
  \begin{tabular}{ |c|c| }
    \hline
    \textbf{Operation} & \textbf{Function} \\
    \hline
    \verb|*iter| & Returns reference to element denoted by the iterator iter \\
    \hline
    \verb|iter -> mem| & Dereference iter and fetch member mem from underlying element, \\
                       & replaces \verb|(*iter).mem| \\
                       \hline
    \verb|++iter| & Increment iterator \\
    \hline
    \verb|--iter| & Decrement iterator \\
    \hline
    \verb|==, !=| & Only equalities, same if denote same element or off the\\
                  & end iterators for the same container \\
                  \hline
  \end{tabular}
\end{center}
\subsection{Iterators and Types}
Library types with iterators define the types \verb|iterator| and \verb|const_iterator|. It is best to use the \verb|const| type when we only need to read from a container.
The operators \verb|cbegin()| and \verb|cend()| are constant replacers for \verb|begin()| and \verb|end()| respectively.
We can see if a dereferenced element is empty: \verb|(*iter)empty()| or \verb|iter -> empty()|. The parentheses are important in this case because it calls what the iterator references and not the iterator itself.

\subsection{Iterator Arithmetic}
Arithmetic on iterators themselves is very powerful, and some library types support it such as \verb|vector| and \verb|string|.
It is important to remember that not all iterators support arithmetic so the following are for \verb|vector| and \verb|string| more generally:
\newline
\begin{center}
  \begin{tabular}{ |c|c| }
    \hline
    Operation & Function \\
    \hline
    \verb|iter + n, iter - n| & Add/subtract integral value to/from an iterator \\
                              & yields iterator n places from iterator \\
                              \hline
    \verb|iter += n, iter -= n| & Compound assignment of value \verb|n| \\
    \hline
    \verb|iter1 - iter2| & Finds the difference in iterator values, produces \\
                         & \verb|difference_type| which is signed \\
                         \hline
    \verb|>, >=, <, <=| & Relational operators, compares value of iterator \\
    \hline
  \end{tabular}
\end{center}
\subsubsection{Binary Search}
A common use of iterator arithmetic is for a \verb|binary search|, used to find a particular value in a container.
The set up of a search is as follows:
\begin{center}
  \begin{enumerate}
    \item Look at item closest to middle 
    \item If is desired value, end search
    \item If value is smaller than the middle value, search first half
    \item Else search second half
    \item Obtain new midpoint
    \item Repeat until search is complete
  \end{enumerate}
\end{center}
\section{Arrays}
An array is a data structure much like a vector, but it is of fixed size and cannot add data element once created.
We can create an array like so: \verb|a[d]| with \verb|a| being the array name and \verb|d| being the array dimensions.
The number of elements in an array must be greater than 0 *and* the dimension must be a \emph{constant expression}.
Arrays, being objects must have a type, either explicitly declared or deduced from a list initialization.
Size can be autodeduced from a list initialization by ignoring the element in \verb|[]|.
The list cannot exceed the dimensions of the array. 

This last part is important, since string literals will add a null character when initializing an array with string literals without list initialization.
The sting literal "test" is 5 characters long unless initialized in a list.
We cannot initialize an array with a copy of another array nor can we assign one array to another.
\subsection{Pointers and References}
Understanding arrays with respect to pointers and references can get complicated:
\begin{center}
  \begin{tabular}{ |c|c| }
    \hline
    Array Definition & Type \\
    \hline
    \verb|int *ptrs[10];| & ptrs is an array of 10 pointers to int \\
    \hline
    \verb|int &refs[10];| & ERROR: cannot create an array of references \\
    \hline
    \verb|int (*Parr)[10] = &arr;| & Parr points to an array of 10 ints \\
    \hline
    \verb|int (&arrRef)[10] = arr;| & arrRef refers to an array of 10 ints \\
    \hline
  \end{tabular}
\end{center}
Defining arrays can get a touch confusing, so its best to work outwards from the array name instead.
The first array is a pointer going left, an array of size 10, and those data elements are of type int going left again.
This should help with the confusion somewhat.
We can't create an array of references since references aren't objects but we can create an array that refers to another.
\subsection{Accesssing Element in an Array}
Accessing elements in an array is very similar to accessing elements in a string or vector.
Indices start at 0, and we can use the \verb|subscript []| operator to access specific elements in that container.
We can even use a variable for the subscript index, but that must have the type \verb|size_t|.
\subsection{Pointers and Arrays}
Arrays and pointers are intertwined fairly tightly in C++, to the point where there is a special operation in C++ in which we can directly get a pointer to the first element in an array without dereferencing the array exactly:

\verb|int *p = arr;|

The address-of operator (\verb|&|) when applied to an array lets us get a pointer to an object in an array.
In effect, pointers to arrays act like iterators in the \verb|string| and \verb|vector| container types.
In most operations on objects of an array type, we can always get a pointer to the first element of an array and perform operations on that.
\subsubsection{Pointers are Iterators}
Since pointers to arrays are so special, we can perform all of the same operations on iterators in the \verb|vector| and \verb|string| container type on pointers to arrays.
To effectively use pointers to arrays as interators we need get the first and one-past-the-last elements of the array.
Unlike \verb|string| and \verb|vector| types, we can use the subscript operator to get the element one past the last element.
Obtaining this element is very similar to the \verb|end()| operator in the \verb|string| and \verb|vector| container type.
And while we can obtain the one-past-the-last element in an array in this manner, it requires knowing the array size in some manner and can cause errors.

Fortunately, \emph{C++11} introduces two new functions for arrays: \verb|begin| and \verb|end|.
Like the iterator counterparts, these return the first and one-past-the-last elements of the array in question.
Unlike them, the array versions are not member functions and thus requirement an argument, one array in this case:

\begin{lstlisting}[language=C++]
    int *beg = begin(arr);
    int *last = end(arr);
\end{lstlisting}

These functions are defined in the \verb|iterator| header.

\subsubsection{Pointer Arithmetic}
Pointers to arrays can take all of the same iterator arithmetic as outlined previously.
When taking the difference between two pointers, the result is of type \verb|ptrdiff_t| in the header \verb|cstdef|.
Relational operators on pointers to an array only work when using related objects.
As we are dealing with pointers, dealing with types can be a touch confusing.
Just remember what you mean with respect to dereferencing pointers to arrays.
\section{Interfacing with Older Code}
C++ in many programs will need to interface with other coding languages, namely C.
It is common to come across this older code and C++ does allow native use of this older style.
There are two prominent examples here:
\subsection{C-Style Character Strings and Library string}
C-style character strings are strings initialized with a series of characters followed by a null character.
They are, in function, an array of characters.
We can use C-style strings when we want to use library \verb|string|s but we can't do the reverse.
Luckily, the \verb|string| library has a member function that lets us return a C-style string: \verb|c_str|
We give it an established library \verb|string| and it returns a C-style string with the type \verb|const char*|.
As these strings are arrays, we can't add to them and we have to manage the pointer aspect of arrays.
If we have a pointer to a C-style string the pointer must point to a null terminated string.
C-style character strings are initialized like so: \verb|char ca[] = "example";|,
giving us a character string "example" which has 8 characters in total.
\begin{center}
  \begin{tabular}{ |c|c| }
    \hline
    \textbf{Operation} & \textbf{Function} \\
    \hline
    \verb|strlen(p)| & Returns length of p not including the null character \\
    \hline
    \verb|strcmp(p1,p2)| & Compares p1 and p2 for equality; returns 0 if \\
                         & p1 == p2, 0 \verb|>| if p1 \verb|>| p2, \& 0 \verb|<| if p1 \verb|<| p2 \\
                         \hline
    \verb|strcat(p1,p2)| & Appends p2 to p1, returns p1 \\
    \hline
    \verb|strcpy(p1,p2)| & Copies p2 into p1, returns p1 \\
    \hline
  \end{tabular}
\end{center}
We cannot compare C-style strings since that would be an operation on pointers, we must use \verb|strcmp|.
We also cannot directly cocantenate and copy C-style strings into one another, \verb|strcat| and \verb|strcpy| must be used respectively.
The trouble is that an appropriately sized C-style string must be used to pass off these values and can cause errors since the 
size of the C-style string \emph{must} be an appopriate size.
This is a huge source of errors, bugs, and security problems.
\subsection{Initializing a vector with an array}
We can't initialize an array with a vector nor can we initialize an array with an array.
We can, however, initialize a vector with an array:
\begin{lstlisting}[language=C++]
    int arr[] = {0,1,2,3,4,5,6,7,8};
    vector<int> ivec(begin(arr), end(arr));
\end{lstlisting}
In effect we are giving the vector the range of some values in an array.
It doesn't have to be the first and one past the last value of the array.
We can use any value of the array subscripted:
\begin{lstlisting}[language=C++]
    vector<int> subVec (arr + 1, arr + 4);
\end{lstlisting}
which gives us a vector filled with values from the array starting at arr[1] and going to arr[3].
The array values used aren't iterative, so we start from arr[0] then add 1, start from arr[0] then add 4 giving use arr[1], arr[3].
\section{My Notes}
\begin{itemize}
  \item Don't use arrays and pointers unless really needed, this includes C-style character strings
\end{itemize}

\chapter{Expressions}
An expression contains one or more operands and yields a result when evaluated.
The most simple expression is a literal.
When evaluated they are the value of the literal.
There are two major type of operators: \textbf{unary} and \textbf{binary}.
\begin{itemize}
  \item Unary operators act on one operand, such as the address-of (\verb|&|) and the dereference (\verb|*|) operator
  \item Binary operators act on two operators, such as the equality (\verb|==|) operator and the multiplication (\verb|*|) operator
\end{itemize}
There are more operator types but aren't very common.

\section{Understanding Expressions}
Understanding expressions requires knowing the precedence and associativity of the operators and the order of evaluation of the operands.

Operands of different types can be converted to a common type in an expression if the types in question are similar.
For instance, an \verb|int| and \verb|float| can be converted to a common type but a \verb|string| and an \verb|int| cannot.
Small integral types (\verb|bool|, \verb|char|, \verb|short|) can be converted to a larger integral type such as \verb|int|.

We say that an operated is \emph{overloaded} when it has multiple meanings depending on the class type in question.
The IO library \verb|>>| and \verb|<<| operators are also used in the \verb|string| and \verb|vector| libraries and with iterators.

\section{lvalue and rvalue}
Since C++ inherits a lot from C, it takes the idea of \verb|lvalues| and \verb|rvalues|.
Every expression in C++ is either a \verb|lvalue| or a \verb|rvalue|.
In C, \verb|lvalues| stood on the left-hand side of assignment whereas \verb|rvalues| did not.
In C++ they have a far more robust meaning.
Generally a \verb|lvalue| resturns an object or a function while a \verb|rvalue| returns the objects content.
Essentially \verb|lvalues| refer to the place in memory of an object (much like pointers).
Because of this we can use an \verb|lvalue| when an \verb|rvalue| is needed but not the reverse.

Many expressions are \verb|lvalues|:
\begin{itemize}
  \item Assignment: uses a non-\verb|const| \verb|lvalue| as left-hand operand and yields it left-hand operand as an \verb|lvalue|.
  \item Address-of: \verb|lvalue| operand, returns a pointer to a operand as an \verb|rvalue|.
  \item Built-in, \verb|string|, and \verb|vector| dereference and subscript operators all yield \verb|lvalues|.
  \item Built-in iterator increment/decrement use \verb|lvalue| operands, the prefix versions yield \verb|lvalues| as well.
\end{itemize}

\section{Order of Evaluation}
While precedence grouping is useful, it lets us know what operations evaluate before others, it doesn't say everything.
Precedence in no way tells us in what order operators of the same group evaluate.
This causes a ton of issues in programs, as the compiler may not detect or do what we want it to.
As a result, unless order of evaluation is specified, it is best practice to never refer to and change an object in an expression if there is no orderc
There are four expressions in which order of evaluation is clearly defined:
\begin{itemize}
  \item \verb|AND (&&)|
  \item \verb=OR (||)=
  \item \verb|Conditional (? :)|
  \item \verb|Comma (,)| 
\end{itemize}
\section{Arithmetic Operators}
Arithmetic operators can be applied to any arithmetic type.
\begin{center}
  \begin{tabular}{ |c|c|c| }
    \hline
    \textbf{Operator} & \textbf{Function} & \textbf{Use} \\
    \hline
    \verb|+| & Unary plus & \verb|+expr| \\
    \hline
    \verb|-| & Unary minus & \verb|-expr| \\
    \hline
    \hline
    \verb|*| & Multiplication & \verb|expr * expr| \\
    \hline
    \verb|/| & Division & \verb|expr / expr| \\
    \hline
    \verb|%| & Modulo/Remainder & \verb|expr % expr| \\
    \hline
    \hline
    \verb|+| & Addition & \verb|expr + expr| \\
    \hline
    \verb|-| & Subtraction & \verb|expr - expr| \\
    \hline
  \end{tabular}
\end{center}
Unary plus returns a copy of the value of the operand.
Unary minus returns the result of negating the operand.
In both cases, the type of the operand can be promoted.
A modulo operation \emph{must} have an integral type.
\section{Logical and Relation Operators}
A relation operator takes arithmetic and pointer type operands, where a value of 0 is \verb|false| and anything else is true.
A logical operator takes any type that can be converted to \verb|bool|.
In both cases the results are returned as \verb|bool|.
Operands are also \verb|rvalues| and result in an \verb|rvalue|.
\begin{center}
  \begin{tabular}{ |c|c|c|c| }
    \hline
    \textbf{Associativity} & \textbf{Operator} & \textbf{Function} & \textbf{Use} \\
    \hline
    Right & \verb|!| & Logical NOT & \verb|!expr| \\
    \hline
    \hline
    Left & \verb|<| & Less than & \verb|expr < expr| \\
    \hline
    Left & \verb|<=| & Less than or equal to & \verb|expr <= expr| \\	
    \hline
    Left & \verb|>| & Greater than & \verb|expr > expr| \\
    \hline
    Left & \verb|=>| & Greater than or equal to  & \verb|expr >= expr| \\
    \hline
    \hline
    Left & \verb|==| & Equality & \verb|expr == expr| \\
    \hline
    Left & \verb|!=| & Inequality & \verb|expr != expr| \\
    \hline
    \hline
    Left & \verb|&&| & Logical AND & \verb|expr && expr| \\
    \hline
    \hline
    Left & \verb=||= & Logical OR & \verb=expr || expr= \\
    \hline
  \end{tabular}
\end{center}
Logical AND and logical OR only evaluate the right operand if and only if the left operand doesn't determine the result of the condition.
For logical AND, the right operand gets evaluated if the left side is \verb|true|.
For logical OR, the right operand gets evaluated if the left side is \verb|false|.

Relational operators always return \verb|bool| values, making a relation like \verb|i < j < k| not work as intended.
Instead the result of the relation must be compared individually like so: \verb|i < j && j < k|.

Equality tests, like relations, return and work on \verb|bool|s. 
This can cause problems.
Sometimes it is helpful to see if a variable has a value (or doesn't) so we know if we can work on it or not.
An equality like \verb|if (val == true)| only makes sense if val is a \verb|bool|.
Essentially, this condition becomes \verb|if (val == 1)|.
The appropriate usage is to just use the variable itself as its own equality in a condition:
\verb|if (val)|.
This will return true if val has any non-zero value.
\section{Assignment Operator}
When assigning, the left-hand operand of the assignment operator must be a modifiable \verb|lvalue|.
This means that literals and arithmetic operators are not allowed as they are \verb|rvalues|.
\verb|const|s are also not allowed since we can't modify them.
With the new standard, list initialization (curly braces) are allowed for assignment but if it is of the built-in type narrowing
conversion is not allowed and only one value is allowed in the list at most.
You can't list initialize an int with a double.
However, some library types are not concerned with this.
\verb|vector| type can use list initialization with less issue.

Assignment is right associative meaning that \verb|i = j = 0| does not behave as expected.
\verb|j = 0| is the right hand operator for \verb|i|. 
Thus \verb|i| gets assigned to the result of \verb|j = 0|.
This is important as we use the assignment operator in more situations.

Assignment has low precedence.
This is a concern when we want to use assignment in conditions.
If we were to have a condition like: \verb|if (p = getPtr() != 0| then we run into an issue.
As assignment has low precedence the condition will get evaluated first.
So we will evaulate \verb|getPtr() != 0| then assign the result to \verb|p|.
We need to be liberal with parentheses to stop this being an issue.
\subsection{Compound Assignment Operators}
Compound assignment is taking an established variable and assigning it to the value of itself plus some object.
This is particularly used in arithmetic types.
\begin{itemize}
  \item Arithmetic compound assignment: \verb|+=|, \verb|-=|, \verb|*=|, \verb|/=|, \verb|%=|
  \item Bitwise compound assignment: \verb|<<=|, \verb|>>=|, \verb|&=|, \verb|^=|
\end{itemize}
\section{Increment and Decrement Operator}
There are prefix and postfix increment/decrement operators.
A prefix will go before the object while a postfix will go after an object.
A prefix increment/decrement operator will change the object then return the changed value.
A postfix increment/decrement operator will change the object but return the unchanged value.
This can cause issues and should only be used when needed.
It is mostly used for dereferenced objects, allowing use to simultaneously access a value in a vector or string while incrementing.
A prefix increment will miss values and cause errors.

An increment/decrement operator requires \verb|lvalue| operands and order of operations should be kept in mind.
\section{Member Access Operator}
The dot \verb|(.)| and arrow \verb|(->)| operators provide for member access.
The dot operator fetches a member from an object of class type while the arrow operator is defined so that \verb|ptr->mem| is a synonym for \verb|(*ptr).mem|.
Member operators have a high precedence, over the dereference operator.
The arrow operator requires a pointer operand and returns an \verb|lvalue|.
The dot operator will return an \verb|lvalue| if the object from which the member is fetch is a \verb|lvalue|.
Else it will return a \verb|rvalue|.
\section{Conditional Operator}
The conditional operator allows us to embed small conditions inside expressions.

\verb|cond ? expr1 : expr2|

where expression 1 is returned if the condition is true and expression 2 is returned if the condition is false.
These expressions need to be the same type or be able to to be converted to a common type if possible.
A conditional operator has low precedence and returns a \verb|lvalue| only if both expressions are or are converted to a \verb|lvalue|.
Else the conditional will return a \verb|rvalue|.
Nesting conditionals is possible where the next conditional is the condition for if the previous conditional is false.
This can get complicated fast so it's recommended to only use 2-3 conditionals in a nest, else use an if block.

\section{Bitwise Operators}
Bitwise operators allow us to operate on the individual bits of an object.
This is helpful for some specific situations and is good practice to be aware of.
\begin{center}
  \begin{tabular}{ |c|c|c| }
    \hline
    \textbf{Operator} & \textbf{Function} & \textbf{Use} \\
    \hline
    \verb|~| & Bitwise NOT & \verb|~expr| \\
    \hline
    \verb|<<| & Left shift & \verb|expr1 << expr2| \\
    \hline
    \verb|>>| & Right shift & \verb|expr1 >> expr2| \\
    \hline
    \verb|&| & Bitwise AND & \verb|expr1 & expr2| \\
    \hline
    \verb|^| & Bitwise XOR & \verb|expr1 ^ expr2| \\
    \hline
    \verb=|= & Bitwise OR & \verb=expr1 | expr2= \\
    \hline
  \end{tabular}
\end{center}
Operands are always converted to the larger integral type if possible before bitwise operations take place.
This includes regular \verb|int| type and character literals.
The operands can be signed or unsigned. 
If the operand is signed and negative, the sign bit is handled differently depending on the system.
It is not recommended to use signed integrals if possible.
Bitwise operators are left associative.

\subsection{Bitwise Shift Operators}
Shift will shift the bits of an object by the right-hand operator.
Left shift might turn a signed \verb|int| into an unsigned one by mistake.
Conversely, a right shift might turn an unsigned \verb|int| into a signed one.
The latter has undefined behavior and should be avoided at all costs.
\subsection{Bitwise NOT}
Bitwise NOT will invert all bits in a value.
This means that the promoted values will get inverted as well.
\subsection{Bitwise AND,OR,XOR}
Bitwise AND will turn a bit to 1 if and only if both equivalent bits in the operand are 1.
Bitwise OR will turn a bit to 1 if either or both operand bits are 1.
Bitwise XOR will turn a bit to one only if either operand bit are 1.

\section{sizeof Operator}
The \verb|sizeof| operator returns the size of an expression or type name.
It is a constant expression of type \verb|size_t|.

\begin{center}
  \verb|sizeof (type)| \\
  \verb|sizeof expr| \\
\end{center}
The value returned for \verb|sizeof expr| is the size of the type returned by the expression.
The \verb|sizeof| operator does not evaluate the operand, contrary to many functions.

\section{Comma operator}
This takes two operands and evaluates them from left to right.
The left hand result is discarded unless it can no longer be evaluated.
The result is the right hand operand, it returns an lvalue if the result is one.
This has the lowest precedence of any operation in C++.
It is most useful in for loops to provide multiple changes after a loop.

\section{Type Conversion}
Since a variety of types are similar to each other, we can convert said types to a common type.
Most of the time we can get away with \emph{implicit conversions}, the conversions that are implied by the programmer or compiler.
Among arithmetic types, they are defined to preserve precision. 
\verb|int| to \verb|double| wouldn't lose any information, but \verb|double| to \verb|int| would.

\subsection{Arithmetic Conversions}
Integral types are generally converted up in size/type. 
The specifics arise when signedness is taken into account.
This can produce undefined behavior so signed types should not be converted blindly.
Generally you can convert positive signed values to an unsigned common type.

\subsection{Implicit Conversions}
\begin{itemize}
  \item \textbf{Array to pointer} - Arrays are automatically converted to a pointer to the first element in an array.
    This isn't used when the array is used with \verb|decltype| or as the operand of address-of, \verb|sizeof|, or \verb|typeid| operators. \\
  \item \textbf{Pointer Conversion} - Constant integral value of 0 and the literal \verb|nullptr| can be converted to any pointer type.
    Any pointer to a nonconst type can be converted to \verb|void*|.
    Any pointer can be converted to a \verb|const verb*|. \\
  \item \textbf{Conversions to bool} - Any pointer or arithmetic value of 0 is converted to false, any other value is true. \\
  \item \textbf{Conversion to const} - Can convert a pointer to a nonconst to a \verb|const| pointer.
    The same holds true for a reference.
  \item \textbf{Conversion Defined by Class Types} - Class types can define their own conversions.
    This is limited to one conversion at a time however.
\end{itemize}

\subsection{Explicit Conversions}
\begin{center}
  \verb|cast_name<type>(expr)|
\end{center}
Sometimes we would like to explicitly convert objects.
This can be done with \emph{casts}.
Casts are inherently dangerous and should only be used if absolutely necessary.
There are a few types of casts: \verb|static_cast|, \verb|const_cast|, and \verb|reinterpret_cast|.
\subsubsection{static\_cast}
This cast is used when there is a well defined conversion.
Its most common in arithmetic conversion. 
It can be also used to do conversions that aren't typically done, like retrieving a pointer value stored in a \verb|void*| pointer.
\subsubsection{const\_cast}
This cast changes a low-level \verb|const| in its operand.
It essentially removes the \verb|const| type.
\subsubsection{reinterpret\_cast}
This cast performs a low-level reinterpretation of the bit pattern of its operands.
This essentially means that the compiler will treat the expression as if it \emph{had} the type.
Use of this cast is almost never recommended, it is very dangerous.
\subsubsection{Old-Style Casts}
Earlier versions of C++ had casts like \verb|type (expr);| or \verb|(type) expr|.
These can act like any of the above casts, and must be interpreted explicitly by the programmer for proper use.
Never use these, just be aware that they can exist in older programs.

In general, casts should not be used.
\verb|static_cast| is the safer of the options, but should only be used if absolutely required by the program.
They can lead to a multitude of errors and problems that are hard to diagnose.

\section{Notes}
\begin{itemize}
  \item C++ has a variety of expressions that apply to the built-in types. 
  \item Expressions have precedence and associativity. 
    Precedence determines how operators are grouped in compound expressions.
    Associativity determines how operators in the same precedence are grouped.
  \item Type conversion is usually implied.
\end{itemize}
\chapter{Statements}
\section{Simple Statements}
Most statements in C++ end in a semicolon.
The \textbf{expression statement} is a simple statement in which an expression is evaluated and its result is discarded.
This kind of statement is most useful in places such as \verb|cout << var|.

The \textbf{null statement} is simply a line of code with just a semicolon.
This is used whenever the program doesn't need a statement but the language expects it, such as an empty while loop.

The \textbf{compound statement} or \textbf{block} is a sequence of statements or declarations surrounded by curly braces.
This is commonly used in loops in which multiple statements are required.
Names declared within a block are local to the block and any blocks within this block.
\section{Conditional Statements}
Conditional statements are statements that can respond to conditions.
There are two kinds of conditional statements in \verb|C++|, \verb|if| and \verb|switch|.
\subsection{if Statement}
An \verb|if| statement conditionally executes another statement depending on the results of the condition.
Every \verb|if| statement needs a condition and a statement.
The condition can be any expression or initialized variable declaration that is of a type that can be converted to a \verb|bool|.

As \verb|if| statements can be used in blocks, a problem called "dangling else" can occur where an \verb|else| statement doesn't go to the \verb|if| statement that was intended.
This can be fixed by using curly braces for every \verb|if| statement and using autoindenting in text editors.

\subsection{switch Statement}
The \verb|switch| statement allows one to conditionally run something based on the result of an expression.
It allows us to choose from a variety of cases.
\begin{lstlisting}[language=C++]
    switch (expr){
        case const integral:
            expr
        default:
            expr
    }
\end{lstlisting}
C++ will execute attempt to execute each case without intervention.
To solve this it is always recommended to \verb|break| at the end of each case label to prevent unwanted action.
A \verb|switch| statement does not have scope, so any variable declared in one case label will not be seen by another, leading to an illegal action.
Variables must be declared outside of the \verb|switch| statement.
The default label will run if no other case label has been executed (assuming proper usage of \verb|break|).
\section{Iterative Statements}
Iterative statements, usually called \emph{loops}, provide for repeated execution until a condition is evaluated to be true.
\subsection{while Statement}
The \verb|while| statement executes a target statement as long as a condition is true:
\begin{lstlisting}[language=C++]
    while (condition)
        statement
\end{lstlisting}
The statement is usually in a block, and is executed as long as the condition evaluates as true.
As soon as the condition is evaluated as false the statement is not executed.
It is never executed if the condition is never evaluated as true.

A \verb|while| loop is generally to read data indefinitely like when reading input.

\subsection{for Statement}
\begin{lstlisting}[language=C++]
  for (init-statement condition; expression)
    statement
\end{lstlisting}
\begin{lstlisting}[language=C++]
  for (initializer; condition; expression)
    statement
\end{lstlisting}
The \verb|for| statement takes an initial condition and some sort of expression that creates a loop.
The variables created in the \verb|for| header must all be the same type.
We can also skip parts of the \verb|for| header:
\begin{lstlisting}[language=C++]
  for (int i = 0; /* no condition */; ++i)
\end{lstlisting}
The code in the for loop must find a way outside of the loop since there's no condition.

\subsection{Range for Statement}
A range \verb|for| statement is designed to iterate over a container or some other sequence.
\begin{lstlisting}[language=C++]
  for (delaration : expression)
    statement
\end{lstlisting}
The expression must represent a sequence, such as a braced initialized list, an array or an object such as a \verb|vector|.
The declaration defines a variable.
This variable must be able to be converted to the type of each element in the sequence.


\end{document} 

